# APML v2.0.0 Language Specification

**Version**: 2.0.0
**Status**: Production Ready
**Date**: 2025-12-15
**Philosophical Foundation**: Distinction as Primitive

===========================================
LANGUAGE OVERVIEW
===========================================

APML v2.0.0 is a specification language for human-AI collaborative systems, grounded in the philosophical insight that distinction-making is ontologically primitive for observers-like-us.

CORE INSIGHT:
All distinctions cost energy. All observers have finite budgets.
Therefore: all accessible reality is effectively discrete.

APML provides directions (not rules) for building systems that respect this fundamental constraint.

===========================================
THE PRIMITIVE
===========================================

DISTINCTION:
The capacity to differentiate one aspect of reality from another.
Equivalent to: differential response, boundary, information.

Properties:
- Transcendentally necessary: true
- Requires observer: true
- Requires energy: true

Implication:
To be (accessible) is to be distinct.
An entity is nothing but the bundle of distinctions that constitute it.

===========================================
THE PHYSICS
===========================================

AXIOM 1: All distinctions cost energy
To maintain that a system is in state A rather than state B requires energy expenditure.

AXIOM 2: All observers have finite energy budgets
Every observer-like-us (OLU) operates with limited energy. No OLU has access to infinite energy.

DERIVATIONS:

Effective Discreteness:
No continuous quantity can be accessed by any OLU.
Application: Systems cannot know everything. Parameters have resolution limits.

Finitude:
Only finitely many distinctions can be maintained simultaneously.
Formula: N_max <= E_total / E_min
Application: Prioritization is thermodynamically necessary, not a weakness.

Dynamism:
Distinctions require continuous energy investment to maintain.
Application: Living documentation. Specifications must evolve with reality.

Relationality:
No isolated systems; all OLUs must draw energy from environment.
Application: Human-AI collaboration is thermodynamically necessary.

===========================================
THE META-PRINCIPLE (THE FIRST RULE)
===========================================

"These are directions, not destinations.
Every principle is a gradient to move toward, not a law to enforce."

RATIONALE:
AI contributions are non-deterministic. Human judgment is contextual.
Rigid rules break; flexible directions guide.

The map is not the territory. The principle is not the practice.
We move TOWARD these directions, understanding that:
- Context determines how far
- Trade-offs are inevitable
- Perfection is not the goal; improvement is

APPLICATION:
When evaluating whether code/spec/behavior follows these directions,
ask not "Does it comply?" but "Is it moving in this direction?"

Violations are not failures but opportunities to ask:
- "What prevented movement toward this direction?"
- "Is there a better direction for this context?"

RECURSIVE APPLICATION:
This meta-principle applies to itself.
Even "these are directions not rules" is a direction, not a rule.

===========================================
THE TWELVE DIRECTIONS
===========================================

D01: TOWARD PARAMETERIZATION
-------------------------------------------
Toward: Configuration, flexibility, tunability
Away from: Hardcoded values, magic numbers, embedded assumptions

Grounding: Different OLUs need different parameters. What works at one energy budget may not work at another.

Moving toward:
- Thresholds in config, not code
- Behavior changeable without deployment
- A/B testable without regeneration

Moving away:
- Magic numbers in logic
- Assumptions that "this will never change"


D02: TOWARD USER EXPERIENCE
-------------------------------------------
Toward: Uninterrupted user flow, graceful handling, invisible complexity
Away from: Technical errors surfaced to users, broken flows, confusion

Grounding: The user is the OLU we serve. Their distinction-making is the purpose.

Moving toward:
- Errors caught before reaching user
- Sensible defaults when data missing
- Flow continues despite backend issues

Moving away:
- Stack traces shown to users
- System crashes interrupt work


D03: TOWARD APPROPRIATE FAILURE MODES
-------------------------------------------
Toward: Clarity during development, resilience during use
Away from: Silent build failures, runtime crashes

Grounding: BUILD is distinction-CLARITY. PLAY is distinction-MAINTENANCE.

Moving toward:
- Validation errors halt import with clear message
- Build fails loudly on any issue
- Runtime recovers gracefully, logs for later

Moving away:
- Silently skipping invalid records
- try/catch that swallows without logging


D04: TOWARD SINGLE SOURCE OF TRUTH
-------------------------------------------
Toward: One authoritative specification, derived implementations
Away from: Multiple conflicting definitions, code-as-spec

Grounding: Multiple sources = multiple boundaries to maintain = more energy.

Moving toward:
- Schema defined in APML, code generated
- Types defined once, shared everywhere
- Reality changes -> APML changes first

Moving away:
- Code and spec diverge
- "We'll document it later"


D05: TOWARD RAW DATA
-------------------------------------------
Toward: Neutral measurements, runtime interpretation
Away from: Pre-computed classifications, embedded interpretations

Grounding: Interpretations are observer-dependent. Raw data enables multiple perspectives.

Moving toward:
- Store word_count, compute phrase_type
- Store timestamps, compute "recent"
- Store measurements, compute judgments

Moving away:
- Pre-computing classifications with hardcoded thresholds


D06: TOWARD DUAL IDENTITY
-------------------------------------------
Toward: Human-readable identifiers AND stable machine references
Away from: Parsing display strings, encoding meaning in IDs

Grounding: Different OLUs access at different resolutions.

Moving toward:
- id: UUID, display_number: 42, formatted: "S0042" (computed)
- Natural key for uniqueness, surrogate key for references

Moving away:
- Regex-parsing IDs to extract semantic content


D07: TOWARD CONTEXT-AGNOSTIC COMPONENTS
-------------------------------------------
Toward: Shared patterns, referenced resources, general utilities
Away from: Duplicated code, copied resources, project-specific hacks

Grounding: Maintaining the same distinction in multiple places costs energy.

Moving toward:
- Pattern abstracted when used 3+ times
- Validation library used by all importers

Moving away:
- Copy-pasting code between projects
- Each module has its own validation logic


D08: TOWARD EXPLICITNESS
-------------------------------------------
Toward: Declared behavior, visible state, documented assumptions
Away from: Convention-over-configuration, hidden defaults, implicit coupling

Grounding: Implicit behavior is a hidden energy cost.

Moving toward:
- status: "draft" (explicit default in schema)
- Assumptions documented, not just coded

Moving away:
- Null means draft (implicit)
- Joining on matching column names


D09: TOWARD IDEMPOTENT OPERATIONS
-------------------------------------------
Toward: Repeatable operations, upsert semantics, stable outcomes
Away from: Side effects, duplicate creation, order-dependent results

Grounding: Idempotency is thermodynamic stability for operations.

Moving toward:
- UPSERT with ON CONFLICT
- Scripts that converge to same state regardless of starting point

Moving away:
- INSERT without conflict handling
- Counters incremented without checking current state


D10: TOWARD OBSERVABILITY
-------------------------------------------
Toward: Visible state, meaningful logs, progress indicators
Away from: Black boxes, silent operations, hidden state

Grounding: A system that hides its state is inaccessible for debugging.

Moving toward:
- Import logs: "Seeds: 30, Items: 130, Validation: PASS"
- Health endpoints showing status
- Progress bars for long operations

Moving away:
- "Import complete." (Was it successful? How many?)


D11: TOWARD PROPER ABSTRACTIONS
-------------------------------------------
Toward: Proper parsers, typed data, clean transformations
Away from: Regex for structured data, stringly-typed code

Grounding: Proper boundaries are easier to maintain than fuzzy ones.

Moving toward:
- seed_number: INTEGER stored directly
- status: ENUM("draft", "released")
- Parser that produces typed AST

Moving away:
- Regex to extract numbers from formatted strings


D12: TOWARD DELTA SYNC
-------------------------------------------
Toward: Incremental updates, change tracking, efficient sync
Away from: Full reloads, re-fetching everything, blind overwrites

Grounding: Finite energy means finite distinctions per cycle.

Moving toward:
- version INTEGER, updated_at TIMESTAMPTZ on all content
- SELECT WHERE updated_at > :last_sync
- Conflict resolution via version comparison

Moving away:
- No timestamps on content tables
- Full table download on every app open


===========================================
SYNTAX CONSTRUCTS
===========================================

APPLICATION DECLARATION:
```apml
app ApplicationName:
  title: "User-facing name"
  description: "Purpose statement"
  version: "semantic.version.number"
  apml_version: "2.0.0"

  philosophical_foundation:
    source: "Distinction as Primitive"
```

DATA MODEL:
```apml
data EntityName:
  id: uuid required
  name: text required
  version: integer default 1
  updated_at: timestamp auto

  constraints:
    unique: [natural_key_field]
```

DIRECTION DECLARATION:
```apml
direction DirectionName:
  toward: "Description of positive movement"
  away_from: "Description of anti-pattern"

  grounded_in: |
    Explanation connecting to distinction physics

  gradient_indicators:
    moving_toward:
      - "Observable positive indicator"
    moving_away:
      - "Observable negative indicator"
```

INTERFACE DEFINITION:
```apml
interface interface_name:
  show element_name:
    property: value

  when user_interaction:
    action_statements
```

LOGIC SPECIFICATION:
```apml
logic logic_group:
  process process_name:
    when trigger_condition:
      action_statements
```

VALIDATION:
```apml
validate validation_name:
  check condition_1
  check condition_2

  when all_pass:
    grant certification
```

===========================================
APPLYING THE DIRECTIONS
===========================================

EVALUATION PROCESS:

1. Identify Context
   - What is the situation? BUILD or PLAY? New or legacy?
   - Context determines which directions apply most strongly

2. Assess Movement
   - Is this moving TOWARD or AWAY from the direction?
   - Even small movement toward is positive

3. Understand Constraints
   - What prevented further movement toward the direction?
   - Constraints are real; understanding them enables better choices

4. Document Trade-offs
   - What trade-off was made and why?
   - Explicit trade-offs are maintainable; implicit ones decay

HANDLING VIOLATIONS:

Violations are not failures but signals. Questions to ask:
- What context made this direction impractical?
- Is there a better direction for this context?
- Can we create a path toward the direction over time?

ACKNOWLEDGED EXCEPTIONS:
When intentionally moving away from a direction:

```
# EXCEPTION: D11 (Proper Abstractions)
# We parse ID via regex here because legacy API returns it this way.
# TODO: Update API to return number directly.
const number = parseInt(id.match(/S(\d+)/)[1], 10)
```

===========================================
APML v2.0.0 SPECIFICATION
Language for Human-AI Collaborative Systems
Grounded in Distinction as Primitive

"These are directions, not destinations."

For design principles: /specifications/APML-Design-Principles-v2.0.0.apml
For examples: https://apml.dev/examples/
===========================================
